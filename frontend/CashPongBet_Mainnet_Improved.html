<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CashPongBet Polygon Mainnet Interface</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.8.1/ethers.umd.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; border-radius: 8px; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        button { margin: 5px; padding: 12px 20px; cursor: pointer; border: none; border-radius: 5px; font-weight: bold; transition: all 0.3s; }
        button:hover { transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .log-entry { margin: 3px 0; font-family: 'Courier New', monospace; font-size: 13px; line-height: 1.4; }
        .timestamp { color: #666; font-weight: bold; }
        #transactionLogs { height: 500px; overflow-y: auto; border: 2px solid #ccc; padding: 15px; background: #000; color: #00ff00; border-radius: 5px; }
        .button-group { margin: 15px 0; display: flex; flex-wrap: wrap; gap: 10px; }
        .primary { background: linear-gradient(45deg, #007bff, #0056b3); color: white; }
        .secondary { background: linear-gradient(45deg, #6c757d, #545b62); color: white; }
        .success { background: linear-gradient(45deg, #28a745, #1e7e34); color: white; }
        .warning { background: linear-gradient(45deg, #ffc107, #e0a800); color: black; }
        .danger { background: linear-gradient(45deg, #dc3545, #c82333); color: white; }
        .info { background: linear-gradient(45deg, #17a2b8, #138496); color: white; }
        .mainnet-warning { background: linear-gradient(45deg, #ff6b35, #f7931e); color: white; }
        h1 { text-align: center; color: #333; margin-bottom: 30px; }
        h3 { color: #555; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
        .status-info { background: #e9ecef; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .highlight { background: #fff3cd; padding: 10px; border-left: 4px solid #ffc107; margin: 10px 0; }
        .mainnet-alert { background: #ff6b35; color: white; padding: 15px; border-radius: 8px; margin: 20px 0; font-weight: bold; }
        .cost-warning { background: #dc3545; color: white; padding: 10px; border-radius: 5px; margin: 10px 0; }
        #disconnectBtn { 
            background: linear-gradient(45deg, #ff3547, #c91111);
            animation: pulseWarning 2s infinite;
        }
        @keyframes pulseWarning {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes blinkWarning {
            0%, 100% { background-color: white; }
            50% { background-color: #fff3cd; }
        }
        body.forfeit-warning {
            animation: blinkWarning 1s infinite;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèì CashPongBet - Polygon Mainnet Interface</h1>
        
        <div class="mainnet-alert">
            <strong>‚ö†Ô∏è POLYGON MAINNET - REAL MONEY!</strong><br>
            üö® You are using REAL MATIC tokens on Polygon Mainnet<br>
            üí∞ All transactions cost real money - be careful!<br>
            üîê Double-check all addresses and amounts before confirming
        </div>

        <div class="highlight">
            <strong>üîß Mainnet Configuration:</strong><br>
            ‚úÖ Network: Polygon Mainnet (Chain ID: 137)<br>
            ‚úÖ Contract: 0xCc50ce04FF06446E0Af663655A4F2B4dFEDb9140<br>
            ‚úÖ Owner: 0x44c994c689ab1eA1c5052477e2F0D5b1fd0D04B8<br>
            ‚úÖ Deployed: August 2, 2025<br>
            ‚ö†Ô∏è Real MATIC - Higher bet amounts recommended
        </div>

        <div class="section">
            <h3>üì± Wallet & Network</h3>
            <div class="button-group">
                <button id="connectWallet" class="primary">üîó Connect Wallet</button>
                <button id="checkBalance" class="info">üí∞ Check MATIC Balance</button>
                <button id="addPolygonNetwork" class="mainnet-warning">üåê Add Polygon Mainnet</button>
            </div>
            <div id="walletInfo" class="status-info"></div>
        </div>

        <div class="section">
            <h3>üîå Session</h3>
            <div class="button-group">
                <button id="disconnectBtn" class="danger">üö™ D√©connecter (Forfait)</button>
            </div>
        </div>

        <div class="section">
            <h3>üìã Contract Management</h3>
            <div class="cost-warning">
                üí∏ <strong>Mainnet Cost Warning:</strong> Contract interactions cost real MATIC. Test thoroughly on testnet first!
            </div>
            <div class="button-group">
                <button id="loadContract" class="primary">üìÑ Load Contract</button>
                <button id="testContract" class="secondary">üîç Test Deployment</button>
                <button id="testParameters" class="info">üìä Check Parameters</button>
            </div>
            <div class="button-group">
                <button id="simpleContractTest" class="warning">üß™ Contract Analysis</button>
            </div>
            <div id="contractInfo" class="status-info"></div>
        </div>

        <div class="section">
            <h3>üéÆ Game Actions</h3>
            <div class="cost-warning">
                üí∞ <strong>Recommended Mainnet Bet:</strong> Minimum 0.01 MATIC (‚âà$0.01 USD)
            </div>
            <div class="button-group">
                <button id="createMainnetRoom" class="success">üéØ Create Mainnet Room</button>
                <button id="joinMainnetRoom" class="success">ü§ù Join Mainnet Room</button>
                <button id="checkRoomStatus" class="info">üìä Check Room Status</button>
            </div>
            <div class="button-group">
                <button id="scorePoint" class="primary">‚ö° Score Point</button>
                <button id="claimVictory" class="warning">‚è∞ Claim Victory</button>
            </div>
        </div>

        <div class="section">
            <h3>üìú Transaction Logs</h3>
            <button onclick="document.getElementById('transactionLogs').innerHTML = ''" class="danger" style="float: right;">üóëÔ∏è Clear Logs</button>
            <div id="transactionLogs"></div>
        </div>
    </div>

    <script>
        class CashPongBetMainnet {
            constructor() {
                this.contractAddress = "0xCc50ce04FF06446E0Af663655A4F2B4dFEDb9140";
                this.contract = null;
                this.provider = null;
                this.signer = null;
                this.currentRoomId = null;
                this.roomFinished = false;
                
                // Mainnet configuration
                this.networkConfig = {
                    chainId: 137, // Polygon Mainnet
                    name: "Polygon Mainnet",
                    rpcUrl: "https://polygon-rpc.com",
                    blockExplorer: "https://polygonscan.com",
                    nativeCurrency: {
                        name: "MATIC",
                        symbol: "MATIC",
                        decimals: 18
                    }
                };
                
                // Player addresses
                this.PLAYERS = {
                    PLAYER1: "0xE6264CEEC98932a778BE80B6C69F37D3e92c1086",
                    PLAYER2: "0x4848F55C17C2C0E5215DEC3953FbB43caBB59BDa"
                };
                
                this.init();
                this.startInactivityMonitor();
            }
        
            async init() {
                try {
                    await this.loadContractABI();
                    this.setupEventListeners();
                    this.setupDisconnectHandlers();
                    this.logTransaction("‚úÖ Polygon Mainnet interface initialized");
                    this.logTransaction("‚ö†Ô∏è Remember: This uses REAL MATIC tokens!");
                    this.logTransaction("üë• Registered Players:");
                    this.logTransaction(`   PLAYER1: ${this.PLAYERS.PLAYER1}`);
                    this.logTransaction(`   PLAYER2: ${this.PLAYERS.PLAYER2}`);
                } catch (error) {
                    this.logTransaction("‚ùå Initialization failed: " + error.message);
                }
            }

            setupDisconnectHandlers() {
                window.addEventListener('beforeunload', async (e) => {
                    if (this.currentRoomId && !this.roomFinished) {
                        e.preventDefault();
                        await this.handleVoluntaryDisconnect();
                        window.close();
                    }
                });

                document.getElementById('disconnectBtn')?.addEventListener('click', async () => {
                    if (this.currentRoomId && !this.roomFinished) {
                        await this.handleVoluntaryDisconnect();
                    }
                });
            }

            async handleVoluntaryDisconnect() {
    try {
        this.logTransaction("‚ö†Ô∏è D√©connexion volontaire d√©tect√©e...");

        const roomId = this.currentRoomId;
        const room = await this.contract.getRoom(roomId);
        const now = Math.floor(Date.now() / 1000);
        const lastAction = Number(room.lastActionTimestamp);
        const diff = now - lastAction;

        const currentAddress = (await this.signer.getAddress()).toLowerCase();
        const isPlayerA = currentAddress === room.playerA.toLowerCase();
        const isPlayerB = currentAddress === room.playerB.toLowerCase();

        this.logTransaction(`üéØ Room ID: ${roomId}`);
        this.logTransaction(`üôã You: ${currentAddress}`);
        this.logTransaction(`üë§ PlayerA: ${room.playerA}`);
        this.logTransaction(`üë§ PlayerB: ${room.playerB}`);
        this.logTransaction(`‚è≥ Time since last action: ${diff} seconds`);

        if (diff >= 60) {
            // Adversaire inactif ‚Üí claim forfait
            if (isPlayerA && !room.playerBForfeited) {
                this.logTransaction("‚è∞ Player B inactif. Requ√™te forfait...");
                const tx = await this.contract.claimVictoryByForfeit(roomId);
                await tx.wait();
                this.roomFinished = true;
                this.logTransaction("‚úÖ Victoire par forfait !");
                return;
            }
            if (isPlayerB && !room.playerAForfeited) {
                this.logTransaction("‚è∞ Player A inactif. Requ√™te forfait...");
                const tx = await this.contract.claimVictoryByForfeit(roomId);
                await tx.wait();
                this.roomFinished = true;
                this.logTransaction("‚úÖ Victoire par forfait !");
                return;
            }

            this.logTransaction("‚ö†Ô∏è Aucun adversaire inactif d√©tect√© ou forfait d√©j√† pris.");
        }

        // Sinon ‚Üí abandon volontaire
        if (isPlayerA && !room.playerAForfeited) {
            this.logTransaction("üòî Vous abandonnez volontairement (Player A)");
            const tx = await this.contract.voluntaryForfeit(roomId);
            await tx.wait();
            this.roomFinished = true;
            this.logTransaction("‚úÖ Forfait volontaire confirm√©.");
            return;
        }
        if (isPlayerB && !room.playerBForfeited) {
            this.logTransaction("üòî Vous abandonnez volontairement (Player B)");
            const tx = await this.contract.voluntaryForfeit(roomId);
            await tx.wait();
            this.roomFinished = true;
            this.logTransaction("‚úÖ Forfait volontaire confirm√©.");
            return;
        }

        this.logTransaction("‚ùå Impossible de forfeit : d√©j√† effectu√© ou conditions non remplies.");

    } catch (error) {
        this.logTransaction(`‚ùå √âchec du forfait: ${error?.message || error}`);
    }
}

        
            async loadContractABI() {
                this.contractABI = [
                    "function owner() external view returns (address)",
                    "function roomCounter() external view returns (uint256)",
                    "function createRoom(address _opponent) external payable",
                    "function joinRoom(uint256 roomId) external payable",
                    "function scorePoint(uint256 roomId, address scorer) external",
                    "function claimVictoryByForfeit(uint256 roomId) external",
                    "function voluntaryForfeit(uint256 roomId) external", 
                    "function ownerForceEnd(uint256 roomId) external",
                    "function getRoom(uint256 roomId) external view returns (tuple(address playerA, address playerB, uint256 betAmount, uint8 scoreA, uint8 scoreB, bool playerAJoined, bool playerBJoined, bool isFinished, uint256 lastActionTimestamp, bool playerAForfeited, bool playerBForfeited))",
                    "function getBalance() external view returns (uint256)",
                    "event RoomCreated(uint256 roomId, address playerA, address playerB, uint256 betAmount)",
                    "event PlayerJoined(uint256 roomId, address player)",
                    "event PointScored(uint256 roomId, address scorer, uint8 scoreA, uint8 scoreB)",
                    "event MatchEnded(uint256 roomId, address winner)",
                    "event VictoryByForfeit(uint256 roomId, address winner)",
                    "event OwnerForcedEnd(uint256 roomId)",
                    "event WinningsPaid(uint256 roomId, address winner, uint256 amount)"
                ];
            }
        
            setupEventListeners() {
                const addListener = (id, handler) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('click', handler);
                        console.log(`‚úÖ Event listener added for ${id}`);
                    } else {
                        console.warn(`‚ö†Ô∏è Element with id '${id}' not found`);
                    }
                };
        
                addListener('connectWallet', () => this.connectWallet());
                addListener('checkBalance', () => this.checkWalletBalance());
                addListener('addPolygonNetwork', () => this.addPolygonNetwork());
                addListener('loadContract', () => this.loadContract());
                addListener('testContract', () => this.testContractDeployment());
                addListener('simpleContractTest', () => this.simpleContractTest());
                addListener('testParameters', () => this.testContractParameters());
                addListener('createMainnetRoom', () => this.createMainnetRoom());
                addListener('joinMainnetRoom', () => this.joinMainnetRoom());
                addListener('checkRoomStatus', () => this.checkRoomStatus());
                addListener('scorePoint', () => this.scoreTestPoint());
                addListener('claimVictory', () => this.claimVictoryTest());
            }
        
            async addPolygonNetwork() {
                try {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x89', // 137 in hex
                            chainName: 'Polygon Mainnet',
                            nativeCurrency: {
                                name: 'MATIC',
                                symbol: 'MATIC',
                                decimals: 18
                            },
                            rpcUrls: ['https://polygon-rpc.com/'],
                            blockExplorerUrls: ['https://polygonscan.com/']
                        }]
                    });
                    this.logTransaction("‚úÖ Polygon Mainnet added to wallet");
                } catch (error) {
                    this.logTransaction("‚ùå Failed to add network: " + error.message);
                }
            }
        
            async connectWallet() {
                try {
                    if (typeof window.ethereum === 'undefined') {
                        this.logTransaction("‚ùå MetaMask not found. Please install MetaMask.");
                        return;
                    }
        
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const address = accounts[0];
        
                    this.provider = new ethers.BrowserProvider(window.ethereum);
                    this.signer = await this.provider.getSigner();
        
                    const network = await this.provider.getNetwork();
                    if (network.chainId !== 137n) {
                        this.logTransaction("‚ö†Ô∏è Please switch to Polygon Mainnet (Chain ID: 137)");
                        this.logTransaction("üí° Click 'Add Polygon Mainnet' button to add the network");
                        return;
                    }
        
                    this.logTransaction("‚úÖ Connected to Polygon Mainnet: " + address);
                    this.updateWalletInfo(address, network);
        
                } catch (error) {
                    this.logTransaction("‚ùå Error connecting wallet: " + error.message);
                }
            }
        
            async loadContract() {
                try {
                    if (!this.provider) {
                        this.logTransaction("‚ùå Please connect wallet first");
                        return;
                    }

                    if (this.contractAddress === "0xCc50ce04FF06446E0Af663655A4F2B4dFEDb9140") {
                        this.logTransaction("‚úÖ Using deployed mainnet contract");
                    } else {
                        this.logTransaction("‚ùå Contract address mismatch");
                        return;
                    }
        
                    this.contract = new ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                    this.logTransaction("‚úÖ Mainnet contract loaded: " + this.contractAddress);
                    this.logTransaction("üîó View on PolygonScan: https://polygonscan.com/address/" + this.contractAddress);
                    this.updateContractInfo();
        
                } catch (error) {
                    this.logTransaction("‚ùå Error loading contract: " + error.message);
                }
            }
        
            async checkWalletBalance() {
                try {
                    if (!this.provider || !this.signer) {
                        this.logTransaction("‚ùå Please connect wallet first");
                        return;
                    }
        
                    const address = await this.signer.getAddress();
                    const balance = await this.provider.getBalance(address);
                    const balanceMatic = ethers.formatEther(balance);
                    
                    this.logTransaction(`üí∞ Mainnet Balance:`);
                    this.logTransaction(`   Address: ${address}`);
                    this.logTransaction(`   Balance: ${balanceMatic} MATIC`);
                    
                    // Get MATIC price (approximate)
                    const maticValue = parseFloat(balanceMatic) * 1.0; // Approximate $1 per MATIC
                    this.logTransaction(`   Approximate Value: $${maticValue.toFixed(2)} USD`);
                    
                    if (parseFloat(balanceMatic) < 0.1) {
                        this.logTransaction(`‚ö†Ô∏è Low balance! Consider adding more MATIC for mainnet transactions`);
                    }
        
                } catch (error) {
                    this.logTransaction("‚ùå Failed to get balance: " + error.message);
                }
            }

            async createMainnetRoom() {
                try {
                    if (!this.contract) {
                        this.logTransaction("‚ùå Please load contract first");
                        return;
                    }
                    
                    // Get opponent address from user
                    const opponentAddress = prompt("Enter opponent's wallet address:");
                    if (!opponentAddress || !ethers.isAddress(opponentAddress)) {
                        this.logTransaction("‚ùå Invalid opponent address");
                        return;
                    }
                    
                    // Get bet amount from user (minimum 0.01 MATIC for mainnet)
                    const betAmountStr = prompt("Enter bet amount in MATIC (minimum 0.01):", "0.01");
                    const betAmount = ethers.parseEther(betAmountStr || "0.01");
                    
                    if (parseFloat(betAmountStr) < 0.01) {
                        this.logTransaction("‚ùå Minimum bet is 0.01 MATIC on mainnet");
                        return;
                    }
                    
                    // Confirmation dialog
                    const confirmed = confirm(
                        `Create room with:\n` +
                        `Opponent: ${opponentAddress}\n` +
                        `Bet: ${betAmountStr} MATIC\n` +
                        `This will cost real money. Continue?`
                    );
                    
                    if (!confirmed) {
                        this.logTransaction("‚ùå Room creation cancelled by user");
                        return;
                    }
                    
                    this.logTransaction(`üéÆ Creating mainnet room...`);
                    this.logTransaction(`   Opponent: ${opponentAddress}`);
                    this.logTransaction(`   Bet: ${betAmountStr} MATIC`);
                    this.logTransaction(`‚ö†Ô∏è This transaction costs real MATIC!`);
                    
                    const tx = await this.contract.createRoom(opponentAddress, { value: betAmount });
                    this.logTransaction(`üìù Transaction submitted: ${tx.hash}`);
                    this.logTransaction(`üîó View on PolygonScan: https://polygonscan.com/tx/${tx.hash}`);
                    this.logTransaction(`‚è≥ Waiting for confirmation...`);
                    
                    const receipt = await tx.wait();
                    this.logTransaction(`‚úÖ Room created! Block: ${receipt.blockNumber}`);
                    
                    // Get room ID from events
                    const roomCreatedEvent = receipt.logs.find(log => {
                        try {
                            const parsed = this.contract.interface.parseLog(log);
                            return parsed.name === "RoomCreated";
                        } catch {
                            return false;
                        }
                    });
                    
                    if (roomCreatedEvent) {
                        const parsed = this.contract.interface.parseLog(roomCreatedEvent);
                        this.currentRoomId = parsed.args.roomId.toString();
                        this.roomFinished = false;
                        this.logTransaction(`üéØ New Room ID: ${this.currentRoomId}`);
                        this.logTransaction(`üí° Share this Room ID with your opponent`);
                    }
                    
                } catch (error) {
                    this.logTransaction(`‚ùå Failed to create room: ${error.message}`);
                    if (error.message.includes("insufficient funds")) {
                        this.logTransaction(`üí° You need more MATIC to create this room`);
                    }
                }
            }

            async joinMainnetRoom() {
                try {
                    if (!this.contract) {
                        this.logTransaction("‚ùå Please load contract first");
                        return;
                    }

                    const roomIdStr = prompt("Enter Room ID to join:");
                    if (!roomIdStr) {
                        this.logTransaction("‚ùå Room ID required");
                        return;
                    }

                    const roomId = parseInt(roomIdStr);
                    const room = await this.safeGetRoom(roomId);

                    if (!room) {
                        this.logTransaction(`‚ùå Room ${roomId} not found`);
                        return;
                    }

                    const currentAddress = await this.signer.getAddress();
                    if (currentAddress.toLowerCase() !== room.playerB.toLowerCase()) {
                        this.logTransaction(`‚ùå You are not invited to room ${roomId}`);
                        return;
                    }

                    if (room.playerBJoined) {
                        this.logTransaction(`‚ùå You have already joined room ${roomId}`);
                        return;
                    }

                    const betAmount = room.betAmount;
                    const betAmountMatic = ethers.formatEther(betAmount);

                    const confirmed = confirm(
                        `Join room ${roomId}?\n` +
                        `Required bet: ${betAmountMatic} MATIC\n` +
                        `This will cost real money. Continue?`
                    );

                    if (!confirmed) {
                        this.logTransaction("‚ùå Join cancelled by user");
                        return;
                    }

                    this.logTransaction(`üéÆ Joining mainnet room ${roomId}...`);
                    this.logTransaction(`   Required bet: ${betAmountMatic} MATIC`);
                    this.logTransaction(`‚ö†Ô∏è This transaction costs real MATIC!`);

                    const tx = await this.contract.joinRoom(roomId, { value: betAmount });
                    this.logTransaction(`üìù Transaction submitted: ${tx.hash}`);
                    this.logTransaction(`üîó View on PolygonScan: https://polygonscan.com/tx/${tx.hash}`);
                    this.logTransaction(`‚è≥ Waiting for confirmation...`);

                    const receipt = await tx.wait();
                    this.logTransaction(`‚úÖ Joined room successfully! Block: ${receipt.blockNumber}`);
                    this.logTransaction(`üéØ Game is now ready to start!`);
                    this.currentRoomId = roomId;
                    this.roomFinished = false;

                } catch (error) {
                    this.logTransaction(`‚ùå Failed to join room: ${error.message}`);
                    if (error.message.includes("insufficient funds")) {
                        this.logTransaction(`üí° You need more MATIC to join this room`);
                    }
                }
            }

            async testContractDeployment() {
                try {
                    this.logTransaction("üîç Testing mainnet contract deployment...");
                    
                    if (!this.provider) {
                        this.logTransaction("‚ùå Please connect wallet first");
                        return;
                    }

                    if (this.contractAddress === "0xCc50ce04FF06446E0Af663655A4F2B4dFEDb9140") {
                        this.logTransaction("‚úÖ Using deployed mainnet contract");
                    } else {
                        this.logTransaction("‚ùå Contract address configuration error");
                        return;
                    }

                    const code = await this.provider.getCode(this.contractAddress);
                    
                    if (code === "0x") {
                        this.logTransaction("‚ùå No contract found at this address on Polygon Mainnet");
                        return;
                    }

                    this.logTransaction("‚úÖ Contract deployed on Polygon Mainnet");
                    this.logTransaction(`üìÑ Contract code length: ${code.length} characters`);

                    this.contract = new ethers.Contract(this.contractAddress, this.contractABI, this.signer);
                    
                    await this.safeContractCall("owner", "Getting contract owner");
                    await this.safeContractCall("roomCounter", "Getting room counter");
                    await this.safeContractCall("getBalance", "Getting contract balance");
                    
                    this.logTransaction("‚úÖ Mainnet contract test completed");

                } catch (error) {
                    this.logTransaction("‚ùå Mainnet contract test failed: " + error.message);
                }
            }

            async safeContractCall(functionName, description, ...args) {
                try {
                    this.logTransaction(`üîç ${description}...`);
                    const result = await this.contract[functionName](...args);
                    
                    if (functionName === "getBalance" || functionName === "roomCounter") {
                        if (functionName === "getBalance") {
                            this.logTransaction(`‚úÖ Contract balance: ${ethers.formatEther(result)} MATIC`);
                        } else {
                            this.logTransaction(`‚úÖ Room counter: ${result.toString()}`);
                        }
                    } else {
                        this.logTransaction(`‚úÖ ${functionName}: ${result}`);
                    }
                    
                    return result;
                } catch (error) {
                    this.logTransaction(`‚ùå Failed ${description}: ${error.message.slice(0, 150)}...`);
                    return null;
                }
            }

            async safeGetRoom(roomId) {
                try {
                    const room = await this.contract.getRoom(roomId);
                    if (room.playerA === "0x0000000000000000000000000000000000000000") {
                        return null;
                    }
                    return room;
                } catch (error) {
                    this.logTransaction(`‚ö†Ô∏è Could not access room ${roomId}: ${error.message.slice(0, 50)}...`);
                    return null;
                }
            }

            async testContractParameters() {
                try {
                    this.logTransaction("üîç Testing mainnet contract parameters...");
                    
                    if (!this.contract) {
                        this.logTransaction("‚ùå Please load contract first");
                        return;
                    }
        
                    const owner = await this.safeContractCall("owner", "Getting owner");
                    const roomCounter = await this.safeContractCall("roomCounter", "Getting room counter");
                    const contractBalance = await this.safeContractCall("getBalance", "Getting contract balance");
        
                    this.logTransaction(`üìã Mainnet Contract Parameters:`);
                    if (owner) {
                        this.logTransaction(`   Owner: ${owner}`);
                        if (owner === "0x44c994c689ab1eA1c5052477e2F0D5b1fd0D04B8") {
                            this.logTransaction(`   ‚úÖ Owner matches deployment info`);
                        }
                    }
                    if (roomCounter) this.logTransaction(`   Room Counter: ${roomCounter.toString()}`);
                    if (contractBalance) {
                        const balanceMatic = ethers.formatEther(contractBalance);
                        this.logTransaction(`   Contract Balance: ${balanceMatic} MATIC`);
                        const usdValue = parseFloat(balanceMatic) * 1.0; // Approximate
                        this.logTransaction(`   Approximate USD Value: ${usdValue.toFixed(2)}`);
                    }
                    this.logTransaction(`   Contract Address: ${this.contractAddress}`);
                    this.logTransaction(`   Deployed: August 2, 2025`);
        
                } catch (error) {
                    this.logTransaction("‚ùå Contract parameters test failed: " + error.message);
                }
            }

            async simpleContractTest() {
                try {
                    this.logTransaction("üß™ STARTING MAINNET CONTRACT ANALYSIS");
                    this.logTransaction("‚ö†Ô∏è  This analyzes the contract WITHOUT spending MATIC");
                    this.logTransaction("==================================================");
                    
                    if (!this.contract) {
                        this.logTransaction("‚ùå Contract not loaded");
                        return;
                    }
                    
                    // Step 1: Test basic contract functions
                    this.logTransaction("üìã Step 1: Testing basic contract functions...");
                    const owner = await this.safeContractCall("owner", "Getting contract owner");
                    const roomCounter = await this.safeContractCall("roomCounter", "Getting room counter");
                    const contractBalance = await this.safeContractCall("getBalance", "Getting contract balance");
                    
                    // Step 2: Verify deployment info
                    this.logTransaction("üìã Step 2: Verifying deployment info...");
                    if (owner === "0x44c994c689ab1eA1c5052477e2F0D5b1fd0D04B8") {
                        this.logTransaction("‚úÖ Owner matches deployment info");
                    } else {
                        this.logTransaction("‚ö†Ô∏è Owner doesn't match expected deployer");
                    }
                    
                    // Step 3: Analyze contract state
                    this.logTransaction("üìã Step 3: Analyzing mainnet contract state...");
                    const roomCount = roomCounter ? Number(roomCounter.toString()) - 1 : 0;
                    const balance = contractBalance ? ethers.formatEther(contractBalance) : "0";
                    
                    this.logTransaction(`üìä Contract State Analysis:`);
                    this.logTransaction(`   üìà Total Rooms Created: ${roomCount}`);
                    this.logTransaction(`   üí∞ Contract Balance: ${balance} MATIC`);
                    
                    if (parseFloat(balance) > 0) {
                        const usdValue = parseFloat(balance) * 1.0;
                        this.logTransaction(`   üíµ Approximate USD Value: ${usdValue.toFixed(2)}`);
                        this.logTransaction(`   üí° Contract has real funds - games in progress`);
                    }
                    
                    // Step 4: Check current user capabilities
                    this.logTransaction("üìã Step 4: Checking current user capabilities...");
                    const currentAddress = await this.signer.getAddress();
                    const isOwner = owner && owner.toLowerCase() === currentAddress.toLowerCase();
                    
                    if (isOwner) {
                        this.logTransaction(`‚úÖ You are the contract owner`);
                        this.logTransaction(`üëë You can use ownerForceEnd() if needed`);
                    } else {
                        this.logTransaction(`‚ÑπÔ∏è Connected as regular user: ${currentAddress}`);
                    }
                    
                    this.logTransaction("üéâ MAINNET CONTRACT ANALYSIS COMPLETED!");
                    this.logTransaction("üí° Contract is ready for real gameplay with real MATIC");
                    
                } catch (error) {
                    this.logTransaction(`‚ùå Contract analysis failed: ${error.message}`);
                }
            }

            async checkRoomStatus() {
                try {
                    if (!this.contract) {
                        this.logTransaction("‚ùå Please load contract first");
                        return;
                    }
                    
                    const roomCounter = await this.safeContractCall("roomCounter", "Getting room counter");
                    if (!roomCounter || roomCounter.toString() === "1") {
                        this.logTransaction("üìä No rooms found on mainnet yet");
                        this.logTransaction("üí° Create the first mainnet room!");
                        return;
                    }
                    
                    const totalRooms = Number(roomCounter.toString()) - 1;
                    this.logTransaction(`üìä Checking status of ${totalRooms} mainnet rooms...`);
                    
                    // Check last 3 rooms
                    const startRoom = Math.max(1, totalRooms - 2);
                    for (let i = startRoom; i <= totalRooms; i++) {
                        const room = await this.safeGetRoom(i);
                        if (room) {
                            this.displayRoomInfo(i, room);
                        }
                    }
                    
                } catch (error) {
                    this.logTransaction(`‚ùå Error checking room status: ${error.message}`);
                }
            }

            displayRoomInfo(roomId, room) {
                try {
                    this.logTransaction(`üìä Mainnet Room ${roomId} Details:`);
                    this.logTransaction(`   Player A: ${room.playerA}`);
                    this.logTransaction(`   Player B: ${room.playerB}`);
                    const betMatic = ethers.formatEther(room.betAmount);
                    const betUsd = parseFloat(betMatic) * 1.0;
                    this.logTransaction(`   Bet Amount: ${betMatic} MATIC (~${betUsd.toFixed(2)})`);
                    this.logTransaction(`   Score: A=${room.scoreA} vs B=${room.scoreB}`);
                    this.logTransaction(`   Players Joined: A=${room.playerAJoined}, B=${room.playerBJoined}`);
                    this.logTransaction(`   Game Status: ${room.isFinished ? "üèÅ Finished" : "üéØ Active"}`);
                    
                    if (room.lastActionTimestamp && room.lastActionTimestamp.toString() !== "0") {
                        const lastAction = new Date(Number(room.lastActionTimestamp) * 1000);
                        this.logTransaction(`   Last Action: ${lastAction.toLocaleString()}`);
                        
                        // Check forfeit eligibility
                        const timeSinceLastAction = Date.now() - (Number(room.lastActionTimestamp) * 1000);
                        const oneMinute = 1 * 60 * 1000;
                        if (timeSinceLastAction > oneMinute && !room.isFinished) {
                            this.logTransaction(`   ‚è∞ Eligible for forfeit claim (>1 minute inactive)`);
                        }
                    }
                    
                    // Show winner
                    if (room.isFinished) {
                        if (room.scoreA >= 10) {
                            this.logTransaction(`   üèÜ Winner: Player A earned ${betMatic * 2} MATIC`);
                        } else if (room.scoreB >= 10) {
                            this.logTransaction(`   üèÜ Winner: Player B earned ${betMatic * 2} MATIC`);
                        } else if (room.playerAForfeited) {
                            this.logTransaction(`   üèÜ Winner: Player B (A forfeited) earned ${betMatic * 2} MATIC`);
                        } else if (room.playerBForfeited) {
                            this.logTransaction(`   üèÜ Winner: Player A (B forfeited) earned ${betMatic * 2} MATIC`);
                        }
                    }
                    
                } catch (error) {
                    this.logTransaction(`‚ùå Error displaying room info: ${error.message}`);
                }
            }

            async scoreTestPoint() {
                try {
                    if (!this.contract) {
                        this.logTransaction("‚ùå Please load contract first");
                        return;
                    }
                    
                    const roomIdStr = prompt("Enter Room ID to score point:");
                    if (!roomIdStr) return;
                    
                    const roomId = parseInt(roomIdStr);
                    const room = await this.safeGetRoom(roomId);
                    
                    if (!room) {
                        this.logTransaction(`‚ùå Room ${roomId} not found`);
                        return;
                    }
                    
                    const currentAddress = await this.signer.getAddress();
                    if (currentAddress.toLowerCase() !== room.playerA.toLowerCase() && 
                        currentAddress.toLowerCase() !== room.playerB.toLowerCase()) {
                        this.logTransaction(`‚ùå You are not a participant in room ${roomId}`);
                        return;
                    }
                    
                    if (!room.playerAJoined || !room.playerBJoined) {
                        this.logTransaction(`‚ùå Both players must join before scoring`);
                        return;
                    }
                    
                    if (room.isFinished) {
                        this.logTransaction(`‚ùå Game is already finished`);
                        return;
                    }
                    
                    const confirmed = confirm(
                        `Score point in room ${roomId}?\n` +
                        `Current score: A=${room.scoreA} vs B=${room.scoreB}\n` +
                        `This will cost gas fees on mainnet.`
                    );
                    
                    if (!confirmed) return;
                    
                    this.logTransaction(`üéØ Scoring point for mainnet room ${roomId}...`);
                    this.logTransaction(`   Current score: A=${room.scoreA} vs B=${room.scoreB}`);
                    
                    const tx = await this.contract.scorePoint(roomId, currentAddress);
                    this.logTransaction(`üìù Transaction submitted: ${tx.hash}`);
                    this.logTransaction(`üîó PolygonScan: https://polygonscan.com/tx/${tx.hash}`);
                    this.logTransaction(`‚è≥ Waiting for confirmation...`);
                    
                    const receipt = await tx.wait();
                    this.logTransaction(`‚úÖ Point scored! Block: ${receipt.blockNumber}`);
                    
                    // Parse events
                    receipt.logs.forEach(log => {
                        try {
                            const parsed = this.contract.interface.parseLog(log);
                            if (parsed.name === "PointScored") {
                                this.logTransaction(`üéØ New score: A=${parsed.args.scoreA} vs B=${parsed.args.scoreB}`);
                            } else if (parsed.name === "MatchEnded") {
                                this.logTransaction(`üèÜ Match ended! Winner: ${parsed.args.winner}`);
                                const winnerEarnings = ethers.formatEther(room.betAmount) * 2;
                                this.logTransaction(`üí∞ Winner earned: ${winnerEarnings} MATIC`);
                            }
                        } catch (e) {}
                    });
                    
                } catch (error) {
                    this.logTransaction(`‚ùå Failed to score point: ${error.message}`);
                }
            }

            async claimVictoryTest() {
                try {
                    if (!this.contract) {
                        this.logTransaction("‚ùå Please load contract first");
                        return;
                    }
                    
                    const roomIdStr = prompt("Enter Room ID to claim victory:");
                    if (!roomIdStr) return;
                    
                    const roomId = parseInt(roomIdStr);
                    const room = await this.safeGetRoom(roomId);
                    
                    if (!room) {
                        this.logTransaction(`‚ùå Room ${roomId} not found`);
                        return;
                    }
                    
                    const currentAddress = await this.signer.getAddress();
                    if (currentAddress.toLowerCase() !== room.playerA.toLowerCase() && 
                        currentAddress.toLowerCase() !== room.playerB.toLowerCase()) {
                        this.logTransaction(`‚ùå You are not a participant in room ${roomId}`);
                        return;
                    }
                    
                    if (room.isFinished) {
                        this.logTransaction(`‚ùå Game is already finished`);
                        return;
                    }
                    
                    // Check timing
                    const timeSinceLastAction = Date.now() - (Number(room.lastActionTimestamp) * 1000);
                    const oneMinute = 1 * 60 * 1000;
                    
                    if (timeSinceLastAction < oneMinute) {
                        const remainingTime = oneMinute - timeSinceLastAction;
                        const remainingSeconds = Math.ceil(remainingTime / 1000);
                        this.logTransaction(`‚ùå Must wait ${remainingSeconds} more seconds`);
                        return;
                    }
                    
                    const winnings = ethers.formatEther(room.betAmount) * 2;
                    const confirmed = confirm(
                        `Claim victory by forfeit in room ${roomId}?\n` +
                        `You will receive: ${winnings} MATIC\n` +
                        `This will cost gas fees on mainnet.`
                    );
                    
                    if (!confirmed) return;
                    
                    this.logTransaction(`‚è∞ Claiming victory by forfeit for room ${roomId}...`);
                    this.logTransaction(`   Potential winnings: ${winnings} MATIC`);
                    
                    const tx = await this.contract.claimVictoryByForfeit(roomId);
                    this.logTransaction(`üìù Transaction submitted: ${tx.hash}`);
                    this.logTransaction(`üîó PolygonScan: https://polygonscan.com/tx/${tx.hash}`);
                    this.logTransaction(`‚è≥ Waiting for confirmation...`);
                    
                    const receipt = await tx.wait();
                    this.logTransaction(`‚úÖ Victory claimed! Block: ${receipt.blockNumber}`);
                    
                    // Parse events
                    receipt.logs.forEach(log => {
                        try {
                            const parsed = this.contract.interface.parseLog(log);
                            if (parsed.name === "VictoryByForfeit") {
                                this.logTransaction(`üèÜ Victory by forfeit! Winner: ${parsed.args.winner}`);
                            } else if (parsed.name === "WinningsPaid") {
                                const amount = ethers.formatEther(parsed.args.amount);
                                this.logTransaction(`üí∞ Winnings paid: ${amount} MATIC (~${(parseFloat(amount) * 1.0).toFixed(2)})`);
                            }
                        } catch (e) {}
                    });
                    
                } catch (error) {
                    this.logTransaction(`‚ùå Failed to claim victory: ${error.message}`);
                }
            }

            startInactivityMonitor() {
            let lastActivity = Date.now();
            const warningThreshold = 5* 60 * 1000; // 5 minutes
            const forfeitThreshold = 10* 60 * 1000; // 10 minutes

            const resetTimer = () => lastActivity = Date.now();

            ['mousemove', 'keydown', 'click'].forEach(event => {
                window.addEventListener(event, resetTimer);
            });

            const checkInactivity = async () => {
                if (this.roomFinished || !this.currentRoomId) return;

                const now = Date.now();
                const inactiveTime = now - lastActivity;

                if (inactiveTime > forfeitThreshold) {
                    this.logTransaction("‚ùå Inactivit√© > 10 minutes : Forfait d√©clench√© automatiquement");
                    await this.handleVoluntaryDisconnect();
                    return;
                }

                if (inactiveTime > warningThreshold) {
                    this.logTransaction("‚ö†Ô∏è Inactivit√© d√©tect√©e : attention au forfait imminent");
                    document.title = "‚ö†Ô∏è INACTIF - Risque de Forfait";
                    document.body.classList.add("forfeit-warning");
                }

                setTimeout(checkInactivity, 30 * 1000); // v√©rifie toutes les 30s
            };

            setTimeout(checkInactivity, 30 * 1000);
        }

        
            updateWalletInfo(address, network) {
                const walletInfo = document.getElementById('walletInfo');
                if (walletInfo) {
                    walletInfo.innerHTML = `
                        <p><strong>Address:</strong> ${address}</p>
                        <p><strong>Chain ID:</strong> ${network?.chainId || 'Unknown'}</p>
                        <p><strong>Network:</strong> ${network?.chainId === 137n ? '‚úÖ Polygon Mainnet' : '‚ö†Ô∏è Wrong Network'}</p>
                        <p><strong>Status:</strong> üí∞ REAL MONEY NETWORK</p>
                    `;
                }
            }

            updateContractInfo() {
                const contractInfo = document.getElementById('contractInfo');
                if (contractInfo) {
                    contractInfo.innerHTML = `
                        <p><strong>Contract Address:</strong> ${this.contractAddress}</p>
                        <p><strong>Status:</strong> ‚úÖ Loaded on Mainnet</p>
                        <p><strong>Network:</strong> Polygon Mainnet</p>
                        <p><strong>Explorer:</strong> <a href="https://polygonscan.com/address/${this.contractAddress}" target="_blank">View on PolygonScan</a></p>
                        <p><strong>‚ö†Ô∏è WARNING:</strong> Real MATIC transactions!</p>
                    `;
                }
            }

            logTransaction(message) {
                const logsContainer = document.getElementById('transactionLogs');
                if (logsContainer) {
                    const timestamp = new Date().toLocaleTimeString();
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry';
                    logEntry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
                    logsContainer.appendChild(logEntry);
                    logsContainer.scrollTop = logsContainer.scrollHeight;
                }
                console.log(message);
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize the mainnet app
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                try {
                    window.cashPongBetMainnet = new CashPongBetMainnet();
                    console.log("‚úÖ CashPongBet Mainnet App initialized");
                } catch (error) {
                    console.error("‚ùå Failed to initialize Mainnet App:", error);
                }
            }, 100);
        });
    </script>

<br><button id="manualForfeitBtn" style="padding: 10px 20px; font-size: 16px;">Forfait (si inactif)</button>
<script>
  const manualBtn = document.getElementById("manualForfeitBtn");

  manualBtn.addEventListener("click", async () => {
    const app = window.cashPongBetMainnet;
    const roomId = app?.currentRoomId;
    const contract = app?.contract;
    const signer = app?.signer;

    if (!roomId || !contract || !signer) {
      alert("Conditions non r√©unies : joueur ou contrat manquant.");
      return;
    }

    try {
      const room = await contract.getRoom(roomId);
      const now = Math.floor(Date.now() / 1000);
      const lastAction = Number(room.lastActionTimestamp);

      if (now <= lastAction + 60) {
        const waitTime = (lastAction + 60) - now;
        alert(`‚è≥ Veuillez patienter ${waitTime} secondes avant de r√©clamer le forfait.`);
        return;
      }

      const confirmed = confirm("√ätes-vous s√ªr de vouloir r√©clamer le forfait ?");
      if (!confirmed) return;

      const tx = await contract.claimVictoryByForfeit(roomId);
      await tx.wait();
      alert("‚úÖ Forfait d√©clench√© !");
    } catch (e) {
      console.error(e);
      alert("‚ùå Erreur : " + (e?.message || e));
    }
  });

  // Suivi activit√©
  window.lastActivityTime = Date.now();
  ['mousemove', 'keydown', 'click'].forEach(event => {
    window.addEventListener(event, () => {
      window.lastActivityTime = Date.now();
    });
  });
</script>

</body>
</html>